@page "/public-events"
@using EventScheduler.Application.DTOs.Response
@using EventScheduler.Web.Services
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.AspNetCore.SignalR.Client
@using System.Text.Json
@rendermode InteractiveServer
@inject ApiService ApiService
@inject NavigationManager NavigationManager
@inject IJSRuntime JSRuntime
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject ILogger<PublicEvents> Logger
@implements IAsyncDisposable

<PageTitle>Public Events - Event Scheduler</PageTitle>

<link rel="stylesheet" href="/css/calendar.css" />

<div class="events-container">
    <!-- Header Section -->
    <div class="calendar-header">
        <div class="header-content">
            <div class="header-text">
                <div class="header-icon">
                    <i class="bi bi-globe"></i>
                </div>
                <div>
                    <h1 class="header-title">Public Events</h1>
                    <p class="header-subtitle">
                        Discover upcoming public events in the community
                    </p>
                </div>
            </div>
            <div class="header-actions">
                @if (!string.IsNullOrEmpty(connectionStatus))
                {
                    <div class="connection-indicator @(isConnected ? "connected" : "disconnected")" title="@connectionStatus">
                        <i class="bi bi-@(isConnected ? "wifi" : "wifi-off")"></i>
                    </div>
                }
                @* @if (!isAuthenticated)
                {
                    <a href="/login" class="btn btn-outline">
                        <i class="bi bi-box-arrow-in-right"></i>
                        <span>Login</span>
                    </a>
                    <a href="/register" class="btn btn-primary">
                        <i class="bi bi-person-plus"></i>
                        <span>Sign Up</span>
                    </a>
                }
                else
                {
                    <a href="/calendar-view" class="btn btn-outline">
                        <i class="bi bi-calendar-heart"></i>
                        <span>My Calendar</span>
                    </a>
                } *@
            </div>
        </div>
    </div>

    <!-- View Toggle -->
    <div class="view-toggle-container">
        <div class="view-toggle">
            <button class="toggle-btn @(viewMode == ViewMode.Calendar ? "active" : "")" @onclick="() => SetViewMode(ViewMode.Calendar)">
                <i class="bi bi-calendar3"></i>
                <span>Calendar View</span>
            </button>
            <button class="toggle-btn @(viewMode == ViewMode.List ? "active" : "")" @onclick="() => SetViewMode(ViewMode.List)">
                <i class="bi bi-list-ul"></i>
                <span>List View</span>
            </button>
        </div>
    </div>

    <!-- Main Content -->
    <div class="events-content">
        @if (isLoading)
        {
            <div class="loading-container">
                <div class="loading-spinner">
                    <div class="spinner"></div>
                </div>
                <div class="loading-text">
                    <h3>Loading Public Events</h3>
                    <p>Getting events ready for you...</p>
                </div>
            </div>
        }
        else
        {
            @if (viewMode == ViewMode.Calendar)
            {
                <!-- Calendar View - Always show calendar -->
                <div class="calendar-card">
                    <div class="calendar-card-body">
                        <div id="public-calendar"></div>
                    </div>
                </div>
            }
            else
            {
                <!-- List View -->
                @if (events.Count == 0)
                {
                    <div class="empty-state">
                        <div class="empty-icon">
                            <i class="bi bi-calendar-x"></i>
                        </div>
                        <div class="empty-text">
                            <h3>No public events yet</h3>
                            <p>Check back later for upcoming public events!</p>
                        </div>
                    </div>
                }
                else
                {
                    <!-- Filter Section -->
                    <div class="filter-section">
                        <div class="filter-row">
                            <div class="filter-item">
                                <label><i class="bi bi-tag"></i> Event Type</label>
                                <select @bind="selectedEventType" @bind:after="FilterEvents" class="form-select">
                                    <option value="">All Types</option>
                                    <option value="Festival">üéâ Festival</option>
                                    <option value="Interview">üíº Interview</option>
                                    <option value="Birthday">üéÇ Birthday</option>
                                    <option value="Exam">üìù Exam</option>
                                    <option value="Appointment">üè• Appointment</option>
                                    <option value="Meeting">üë• Meeting</option>
                                    <option value="Reminder">‚è∞ Reminder</option>
                                    <option value="Task">‚úÖ Task</option>
                                    <option value="Other">Other</option>
                                </select>
                            </div>
                            <div class="filter-item">
                                <label><i class="bi bi-search"></i> Search</label>
                                <input type="text" @bind="searchQuery" @bind:after="FilterEvents" 
                                       class="form-control" placeholder="Search events..." />
                            </div>
                        </div>
                    </div>

                    <!-- List View -->
                    <div class="events-grid">
                        @foreach (var evt in filteredEvents.OrderBy(e => e.StartDate))
                        {
                        <div class="event-card @GetEventTypeClass(evt.EventType)" @onclick="() => ShowEventDetails(evt)">
                            <div class="event-card-header">
                                <div class="event-title-section">
                                    <h3 class="event-title">@evt.Title</h3>
                                    <div class="event-badges">
                                        <span class="badge badge-type">
                                            @GetEventTypeIcon(evt.EventType) @evt.EventType
                                        </span>
                                    </div>
                                </div>
                            </div>

                            <div class="event-card-body">
                                @if (!string.IsNullOrEmpty(evt.Description))
                                {
                                    <p class="event-description">@evt.Description</p>
                                }

                                <div class="event-details">
                                    <div class="event-detail-item">
                                        <i class="bi bi-calendar3"></i>
                                        <span>@evt.StartDate.ToString("MMM dd, yyyy")</span>
                                    </div>

                                    @if (!evt.IsAllDay)
                                    {
                                        <div class="event-detail-item">
                                            <i class="bi bi-clock"></i>
                                            <span>@evt.StartDate.ToString("hh:mm tt") - @evt.EndDate.ToString("hh:mm tt")</span>
                                        </div>
                                    }
                                    else
                                    {
                                        <div class="event-detail-item">
                                            <i class="bi bi-sun"></i>
                                            <span>All Day</span>
                                        </div>
                                    }

                                    @if (!string.IsNullOrEmpty(evt.Location))
                                    {
                                        <div class="event-detail-item">
                                            <i class="bi bi-geo-alt"></i>
                                            <span>@evt.Location</span>
                                        </div>
                                    }

                                    @if (evt.ParticipantsCount > 0)
                                    {
                                        <div class="event-detail-item">
                                            <i class="bi bi-people"></i>
                                            <span>@evt.ParticipantsCount participant@(evt.ParticipantsCount == 1 ? "" : "s")</span>
                                        </div>
                                    }
                                </div>
                            </div>
                        </div>
                    }
                </div>
                }
            }
        }
    </div>
</div>

<!-- Event Details Modal -->
@if (selectedEvent != null)
{
    <div class="modal-overlay" @onclick="CloseModal">
        <div class="modal-content" @onclick:stopPropagation="true">
            <div class="modal-header">
                <h2>@selectedEvent.Title</h2>
                <button class="btn-close" @onclick="CloseModal">
                    <i class="bi bi-x-lg"></i>
                </button>
            </div>
            <div class="modal-body">
                <div class="event-type-badge">
                    @GetEventTypeIcon(selectedEvent.EventType) @selectedEvent.EventType
                </div>
                
                @if (!string.IsNullOrEmpty(selectedEvent.Description))
                {
                    <p class="description">@selectedEvent.Description</p>
                }

                <div class="details-grid">
                    <div class="detail-row">
                        <strong><i class="bi bi-calendar3"></i> Date:</strong>
                        <span>@selectedEvent.StartDate.ToString("MMMM dd, yyyy")</span>
                    </div>

                    <div class="detail-row">
                        <strong><i class="bi bi-clock"></i> Time:</strong>
                        <span>
                            @if (selectedEvent.IsAllDay)
                            {
                                <text>All Day Event</text>
                            }
                            else
                            {
                                @selectedEvent.StartDate.ToString("hh:mm tt") <text> - </text> @selectedEvent.EndDate.ToString("hh:mm tt")
                            }
                        </span>
                    </div>

                    @if (!string.IsNullOrEmpty(selectedEvent.Location))
                    {
                        <div class="detail-row">
                            <strong><i class="bi bi-geo-alt"></i> Location:</strong>
                            <span>@selectedEvent.Location</span>
                        </div>
                    }

                    @if (selectedEvent.ParticipantsCount > 0)
                    {
                        <div class="detail-row">
                            <strong><i class="bi bi-people"></i> Participants:</strong>
                            <span>@selectedEvent.ParticipantsCount</span>
                        </div>
                    }
                </div>

                @if (isAuthenticated)
                {
                    <div class="modal-actions" style="margin-top: 1.5rem; display: flex; gap: 0.75rem; justify-content: flex-end;">
                        @if (IsUserJoined(selectedEvent))
                        {
                            <button class="btn btn-outline" @onclick="async () => await LeaveEvent(selectedEvent.Id)" disabled="@isProcessing">
                                <i class="bi bi-box-arrow-right"></i>
                                @(isProcessing ? "Leaving..." : "Leave Event")
                            </button>
                        }
                        else
                        {
                            <button class="btn btn-primary" @onclick="async () => await JoinEvent(selectedEvent.Id)" disabled="@isProcessing">
                                <i class="bi bi-person-plus"></i>
                                @(isProcessing ? "Joining..." : "Join Event")
                            </button>
                        }
                    </div>
                }
            </div>
        </div>
    </div>
}

@code {
    private List<EventResponse> events = new();
    private List<EventResponse> filteredEvents = new();
    private EventResponse? selectedEvent = null;
    private bool isLoading = true;
    private bool isAuthenticated = false;
    private bool isProcessing = false;
    private string selectedEventType = "";
    private string searchQuery = "";
    private ViewMode viewMode = ViewMode.Calendar;
    private DotNetObjectReference<PublicEvents>? dotNetHelper;
    private bool calendarInitialized = false;
    private bool initializationAttempted = false; // Prevents multiple initialization attempts
    private int currentUserId = 0;
    
    // SignalR for real-time updates
    private HubConnection? hubConnection;
    private bool isConnected = false;
    private string connectionStatus = "";

    public enum ViewMode
    {
        List,
        Calendar
    }

    protected override async Task OnInitializedAsync()
    {
        Logger.LogInformation("PublicEvents: Component initializing");
        
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        isAuthenticated = authState.User.Identity?.IsAuthenticated ?? false;
        
        if (isAuthenticated)
        {
            var userIdClaim = authState.User.FindFirst("userId");
            if (userIdClaim != null && int.TryParse(userIdClaim.Value, out var userId))
            {
                currentUserId = userId;
            }
        }
        
        // Load data and setup SignalR in parallel
        await Task.WhenAll(
            LoadPublicEvents(),
            InitializeSignalR()
        );
        
        Logger.LogInformation("PublicEvents: Initialization complete, loading={IsLoading}, events={Count}", isLoading, events.Count);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        Logger.LogInformation("PublicEvents: OnAfterRenderAsync called - firstRender={FirstRender}, viewMode={ViewMode}, calendarInitialized={CalendarInitialized}, isLoading={IsLoading}", 
            firstRender, viewMode, calendarInitialized, isLoading);
        
        // ONLY initialize on first render after data loads
        // This prevents re-initialization on every render
        if (firstRender && viewMode == ViewMode.Calendar && !calendarInitialized && !isLoading)
        {
            Logger.LogInformation("PublicEvents: Conditions met for calendar initialization");
            await InitializeCalendar();
        }
        else
        {
            Logger.LogInformation("PublicEvents: Skipping calendar init - conditions not met");
        }
    }

    private async Task LoadPublicEvents()
    {
        isLoading = true;
        Logger.LogInformation("PublicEvents: Loading events from API");
        
        try
        {
            var response = await ApiService.GetPublicEventsAsync();
            if (response != null)
            {
                events = response;
                filteredEvents = events;
                Logger.LogInformation("PublicEvents: Loaded {Count} events", events.Count);
            }
            else
            {
                Logger.LogWarning("PublicEvents: API returned null response");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "PublicEvents: Error loading events");
        }
        finally
        {
            isLoading = false;
            Logger.LogInformation("PublicEvents: Loading complete, isLoading={IsLoading}", isLoading);
            
            // If we're in calendar mode and haven't initialized yet, trigger initialization
            if (viewMode == ViewMode.Calendar && !calendarInitialized)
            {
                StateHasChanged(); // Trigger OnAfterRenderAsync with isLoading=false
                await Task.Delay(100); // Give time for render
                
                // Initialize directly if still not initialized
                if (!calendarInitialized)
                {
                    await InitializeCalendar();
                }
            }
        }
    }

    private async Task InitializeSignalR()
    {
        try
        {
            // Public events don't require authentication for viewing
            var hubUrl = "http://localhost:5006/hubs/events";
            
            hubConnection = new HubConnectionBuilder()
                .WithUrl(hubUrl)
                .WithAutomaticReconnect()
                .ConfigureLogging(logging => {
                    logging.SetMinimumLevel(LogLevel.Information);
                })
                .Build();

            // Connection lifecycle handlers
            hubConnection.Reconnecting += OnReconnecting;
            hubConnection.Reconnected += OnReconnected;
            hubConnection.Closed += OnClosed;

            // Register event handlers for real-time updates
            RegisterSignalRHandlers();

            await hubConnection.StartAsync();
            
            isConnected = true;
            connectionStatus = "Connected to real-time updates";
            Logger.LogInformation("PublicEvents SignalR: Connected (Connection ID: {ConnectionId})", hubConnection.ConnectionId);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "PublicEvents SignalR: Connection failed");
            connectionStatus = "Real-time updates unavailable";
            isConnected = false;
        }
    }

    private void RegisterSignalRHandlers()
    {
        if (hubConnection == null) return;

        // Event created handler - add new public events
        hubConnection.On<EventResponse>("EventCreated", async (eventData) => {
            await InvokeAsync(async () => {
                // Only add if it's a public event
                if (eventData.IsPublic)
                {
                    Logger.LogInformation("PublicEvents: New public event created - {Title}", eventData.Title);
                    events.Add(eventData);
                    
                    // Re-apply filters
                    FilterEvents();
                    
                    // Update calendar if in calendar view
                    if (viewMode == ViewMode.Calendar && calendarInitialized)
                    {
                        await JSRuntime.InvokeVoidAsync("addEventToCalendar", eventData);
                    }
                    
                    StateHasChanged();
                }
            });
        });

        // Event updated handler
        hubConnection.On<EventResponse>("EventUpdated", async (eventData) => {
            await InvokeAsync(async () => {
                var existingEvent = events.FirstOrDefault(e => e.Id == eventData.Id);
                
                // Handle visibility changes
                if (existingEvent != null && !eventData.IsPublic)
                {
                    // Event was made private - remove it
                    Logger.LogInformation("PublicEvents: Event {Title} made private - removing", eventData.Title);
                    events.Remove(existingEvent);
                    FilterEvents();
                    
                    if (viewMode == ViewMode.Calendar && calendarInitialized)
                    {
                        await JSRuntime.InvokeVoidAsync("removeEventFromCalendar", eventData.Id);
                    }
                }
                else if (existingEvent != null && eventData.IsPublic)
                {
                    // Event updated and still public
                    Logger.LogInformation("PublicEvents: Public event updated - {Title}", eventData.Title);
                    events.Remove(existingEvent);
                    events.Add(eventData);
                    FilterEvents();
                    
                    if (viewMode == ViewMode.Calendar && calendarInitialized)
                    {
                        await JSRuntime.InvokeVoidAsync("updateEventInCalendar", eventData);
                    }
                }
                else if (existingEvent == null && eventData.IsPublic)
                {
                    // Private event was made public - add it
                    Logger.LogInformation("PublicEvents: Event {Title} made public - adding", eventData.Title);
                    events.Add(eventData);
                    FilterEvents();
                    
                    if (viewMode == ViewMode.Calendar && calendarInitialized)
                    {
                        await JSRuntime.InvokeVoidAsync("addEventToCalendar", eventData);
                    }
                }
                
                StateHasChanged();
            });
        });

        // Event deleted handler
        hubConnection.On<object>("EventDeleted", async (deletedEventInfo) => {
            await InvokeAsync(async () => {
                var eventId = ExtractEventId(deletedEventInfo);
                var eventToRemove = events.FirstOrDefault(e => e.Id == eventId);
                
                if (eventToRemove != null)
                {
                    Logger.LogInformation("PublicEvents: Event deleted - {Title}", eventToRemove.Title);
                    events.Remove(eventToRemove);
                    FilterEvents();
                    
                    if (viewMode == ViewMode.Calendar && calendarInitialized)
                    {
                        await JSRuntime.InvokeVoidAsync("removeEventFromCalendar", eventId);
                    }
                    
                    StateHasChanged();
                }
            });
        });
    }

    private int ExtractEventId(object deletedEventInfo)
    {
        var json = JsonSerializer.Serialize(deletedEventInfo);
        var doc = JsonDocument.Parse(json);
        return doc.RootElement.GetProperty("id").GetInt32();
    }

    private Task OnReconnecting(Exception? exception)
    {
        Logger.LogWarning(exception, "PublicEvents SignalR: ‚ö†Ô∏è Connection lost, attempting to reconnect...");
        connectionStatus = "Reconnecting to real-time updates...";
        isConnected = false;
        InvokeAsync(StateHasChanged);
        return Task.CompletedTask;
    }

    private Task OnReconnected(string? connectionId)
    {
        Logger.LogInformation("PublicEvents SignalR: ‚úì Reconnected successfully (Connection ID: {ConnectionId})", connectionId);
        connectionStatus = "Connected to real-time updates";
        isConnected = true;
        InvokeAsync(StateHasChanged);
        return Task.CompletedTask;
    }

    private Task OnClosed(Exception? exception)
    {
        Logger.LogWarning(exception, "PublicEvents SignalR: Connection closed");
        connectionStatus = "Real-time updates unavailable";
        isConnected = false;
        InvokeAsync(StateHasChanged);
        return Task.CompletedTask;
    }

    private async Task SetViewMode(ViewMode mode)
    {
        Logger.LogInformation("PublicEvents: Switching view mode from {PreviousMode} to {NewMode}", viewMode, mode);
        
        var previousMode = viewMode;
        viewMode = mode;
        
        if (mode == ViewMode.Calendar)
        {
            // Switching TO calendar view
            StateHasChanged();
            await Task.Delay(300); // Give DOM time to render calendar element
            
            // Initialize calendar if coming from list view or not yet initialized
            if (previousMode == ViewMode.List || !calendarInitialized)
            {
                await InitializeCalendar();
            }
        }
        else if (previousMode == ViewMode.Calendar && calendarInitialized)
        {
            // Switching FROM calendar view - destroy properly
            try
            {
                await JSRuntime.InvokeVoidAsync("fullCalendarInterop.destroy", "public-calendar");
                calendarInitialized = false;
                initializationAttempted = false; // Allow re-initialization when switching back
                Logger.LogInformation("PublicEvents: Calendar destroyed successfully");
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "PublicEvents: Error destroying calendar");
                calendarInitialized = false;
                initializationAttempted = false;
            }
        }
    }

    private async Task InitializeCalendar()
    {
        // Prevent double initialization
        if (calendarInitialized || initializationAttempted)
        {
            Logger.LogInformation("PublicEvents: Calendar already initialized or attempt in progress, skipping");
            return;
        }

        initializationAttempted = true; // Mark that we're attempting initialization
        
        try
        {
            Logger.LogInformation("PublicEvents: Attempting to initialize calendar with {Count} events", filteredEvents.Count);
            
            // Ensure DOM element exists
            var elementExists = await JSRuntime.InvokeAsync<bool>("eval", "document.getElementById('public-calendar') !== null");
            if (!elementExists)
            {
                Logger.LogError("PublicEvents: Calendar element 'public-calendar' not found in DOM");
                initializationAttempted = false; // Reset flag to allow retry
                return;
            }
            
            // Check if there's an existing calendar instance and destroy it
            try
            {
                var hasExistingCalendar = await JSRuntime.InvokeAsync<bool>("eval", 
                    "window.fullCalendarInterop && window.fullCalendarInterop.calendars && window.fullCalendarInterop.calendars['public-calendar'] !== undefined");
                
                if (hasExistingCalendar)
                {
                    Logger.LogWarning("PublicEvents: Found existing calendar instance, destroying it first");
                    await JSRuntime.InvokeVoidAsync("fullCalendarInterop.destroy", "public-calendar");
                    await Task.Delay(100); // Give time for cleanup
                }
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "PublicEvents: Error checking/destroying existing calendar");
            }
            
            dotNetHelper = DotNetObjectReference.Create(this);
            var calendarEvents = ConvertToFullCalendarFormat();
            
            // Give time for DOM to be fully ready and CSS to apply
            await Task.Delay(500);
            
            var initialized = await JSRuntime.InvokeAsync<bool>("fullCalendarInterop.initialize", 
                "public-calendar", dotNetHelper, calendarEvents, false);
            
            if (initialized)
            {
                calendarInitialized = true;
                Logger.LogInformation("PublicEvents: Calendar initialized successfully with {Count} events", calendarEvents.Length);
                
                // Force calendar to recalculate size after initialization
                await Task.Delay(100);
                await JSRuntime.InvokeVoidAsync("fullCalendarInterop.updateSize", "public-calendar");
                Logger.LogInformation("PublicEvents: Calendar size updated");
            }
            else
            {
                Logger.LogWarning("PublicEvents: Calendar initialization returned false");
                initializationAttempted = false; // Reset flag to allow retry
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "PublicEvents: Error initializing calendar");
            initializationAttempted = false; // Reset flag to allow retry
        }
    }

    private object[] ConvertToFullCalendarFormat()
    {
        return filteredEvents.Select(e => new
        {
            id = e.Id,
            title = e.Title,
            start = e.StartDate.ToString("yyyy-MM-ddTHH:mm:ss"),
            end = e.EndDate.ToString("yyyy-MM-ddTHH:mm:ss"),
            allDay = e.IsAllDay,
            backgroundColor = "#667eea",
            borderColor = "#667eea",
            extendedProps = new
            {
                description = e.Description,
                location = e.Location,
                eventType = e.EventType
            }
        }).ToArray();
    }

    [JSInvokable]
    public Task OnEventClick(int eventId)
    {
        var evt = events.FirstOrDefault(e => e.Id == eventId);
        if (evt != null)
        {
            ShowEventDetails(evt);
            StateHasChanged(); // Force UI update to show modal
        }
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task OnDateSelect(string startStr, string endStr, bool allDay)
    {
        // Public calendar is read-only, do nothing
        return Task.CompletedTask;
    }

    private void FilterEvents()
    {
        filteredEvents = events.Where(e =>
        {
            bool matchesType = string.IsNullOrEmpty(selectedEventType) || e.EventType == selectedEventType;
            bool matchesSearch = string.IsNullOrEmpty(searchQuery) ||
                                e.Title.Contains(searchQuery, StringComparison.OrdinalIgnoreCase) ||
                                (e.Description?.Contains(searchQuery, StringComparison.OrdinalIgnoreCase) ?? false);
            return matchesType && matchesSearch;
        }).ToList();

        // Update calendar if in calendar view
        if (viewMode == ViewMode.Calendar && calendarInitialized)
        {
            var calendarEvents = ConvertToFullCalendarFormat();
            JSRuntime.InvokeVoidAsync("fullCalendarInterop.updateEvents", calendarEvents);
        }
    }

    private void ShowEventDetails(EventResponse evt)
    {
        selectedEvent = evt;
        StateHasChanged(); // Force UI update to show modal
    }

    private void CloseModal()
    {
        selectedEvent = null;
        StateHasChanged(); // Force UI update to hide modal
    }

    private string GetEventTypeClass(string eventType)
    {
        return eventType.ToLower() switch
        {
            "festival" => "event-type-festival",
            "interview" => "event-type-interview",
            "birthday" => "event-type-birthday",
            "exam" => "event-type-exam",
            "appointment" => "event-type-appointment",
            "meeting" => "event-type-meeting",
            _ => "event-type-other"
        };
    }

    private string GetEventTypeIcon(string eventType)
    {
        return eventType.ToLower() switch
        {
            "festival" => "üéâ",
            "interview" => "üíº",
            "birthday" => "üéÇ",
            "exam" => "üìù",
            "appointment" => "üè•",
            "meeting" => "üë•",
            "reminder" => "‚è∞",
            "task" => "‚úÖ",
            _ => "üìÖ"
        };
    }

    private bool IsUserJoined(EventResponse evt)
    {
        if (!isAuthenticated || currentUserId == 0 || evt.Invitations == null)
            return false;
        
        return evt.Invitations.Any(i => i.UserId == currentUserId);
    }

    private async Task JoinEvent(int eventId)
    {
        if (!isAuthenticated)
        {
            NavigationManager.NavigateTo("/login");
            return;
        }

        isProcessing = true;
        StateHasChanged();

        try
        {
            var updatedEvent = await ApiService.JoinPublicEventAsync(eventId);
            if (updatedEvent != null)
            {
                // Update the event in the list
                var eventIndex = events.FindIndex(e => e.Id == eventId);
                if (eventIndex >= 0)
                {
                    events[eventIndex] = updatedEvent;
                }

                // Update selected event if it's the same one
                if (selectedEvent?.Id == eventId)
                {
                    selectedEvent = updatedEvent;
                }

                FilterEvents();
                Logger.LogInformation("Successfully joined event {EventId}", eventId);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error joining event {EventId}", eventId);
        }
        finally
        {
            isProcessing = false;
            StateHasChanged();
        }
    }

    private async Task LeaveEvent(int eventId)
    {
        isProcessing = true;
        StateHasChanged();

        try
        {
            await ApiService.LeaveEventAsync(eventId);
            
            // Refresh the event data
            await LoadPublicEvents();
            
            // Close the modal
            CloseModal();
            
            Logger.LogInformation("Successfully left event {EventId}", eventId);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error leaving event {EventId}", eventId);
        }
        finally
        {
            isProcessing = false;
            StateHasChanged();
        }
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            if (calendarInitialized)
            {
                await JSRuntime.InvokeVoidAsync("fullCalendarInterop.destroy", "public-calendar");
                calendarInitialized = false;
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error disposing calendar");
        }

        try
        {
            if (hubConnection != null)
            {
                await hubConnection.StopAsync();
                await hubConnection.DisposeAsync();
                Logger.LogInformation("PublicEvents SignalR: Connection disposed");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error disposing SignalR connection");
        }

        dotNetHelper?.Dispose();
    }
}

<!-- ============================================
     ‚úÖ All styles moved to: wwwroot/css/pages/public-events.css
     This includes: connection indicator, view toggle, calendar card, filters, event cards, modals, and responsive design
     ============================================ -->

